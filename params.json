{"name":"QVTom","tagline":"A Modular Extension for QVTo","body":"# QVTom\r\n\r\nQVTom is a prototypical implementation of the module system for model transformation languages described in [[1]](#references). It replaces the default structure of a QVTo transformation with the definition of interfaces and interface implementations where implementations can be linked to interfaces with an export or import relationship.\r\n\r\nThe changes that have been made to the QVTo plugin [[2]](#references) are described in this document.\r\n\r\n\r\n## Changes to the AST/CST\r\n\r\n### Changes to the meta models\r\nLegend:\r\n\r\nElement                       |  Representation\r\n----------------------------- | ----------------\r\nCST\t                      |  **CST: ...**\r\nAST\t                      |  **AST: ...**\r\nline number in QVTOParser.gi  |  **\\<n\\>**\r\n\r\n<pre>modeltype PCM uses <em>'http://sdq.ipd.uka.de/PalladioComponentModel/5.0'</em>;\r\nmodeltype PCM_ALLOC uses <em>'http://sdq.ipd.uka.de/PalladioComponentModel/Allocation/5.0'</em>;\r\nmodeltype PCM_REP uses <em>'http://sdq.ipd.uka.de/PalladioComponentModel/Repository/5.0'</em>;\r\n\r\ncompilation_environment <em>\"Commons\"</em>;\r\n<b>CST: CompilationEnvironmentCS[uriCS = \"Commons\"] <547></b>\r\ncompilation_environment <em>\"EventChannelMiddlewareRegistry\"</em>;\r\ncompilation_environment <em>\"EventDistribution\"</em>;\r\ncompilation_environment <em>\"EventFilter\"</em>;\r\n...\r\n\r\ninterface ISink( \r\n\tinout pcmAllocation : PCM_ALLOC,\r\n    <b>CST: InterfaceInOutParamCS[param = ParameterDeclarationCS[simpleNameCS = \"pcmAllocation\", typeSpecCS = PCM_ALLOC, directionKind = inout]]</b>\r\n    <b>AST: InterfaceRestrictionParameter[param = VarParameter[parsed by original parser]]</b>\r\n\tinout pcmSystem : PCM_SYS, \r\n\tinout pcmRepository : PCM_REP,\r\n\tin middlewareRepository : PCM_REP;\r\n\t\r\n\tin PCM_ALLOC[Allocation]\r\n\t  <b>CST: InterfaceRestrictionParamCS[param = PCM_ALLOC, classes = {Allocation::TypeSpecCS}, packages = {}] &lt;780&gt;</b>\r\n\t  <b>AST: InterfaceRestrictionParameter</b>\r\n)\r\n  <b>AST: InterfaceParamsCS[…] <680></b>\r\n  <b>AST: ModuleHeaderCS[pathNameCS=\"ISink\", interfaceInOutParamsCS=..., interfaceRestrictionParamsCS=...] &lt;581&gt;</b>\r\n{\r\n\tmapping Sink_createSinkOperationProvidedRole(sinkComponent : pcm::repository::RepositoryComponent,\r\n\t                                             operationInterface : pcm::repository::OperationInterface) : pcm::repository::OperationProvidedRole;\r\n    <b>&lt;830&gt; - declarations: mapping_decl / helper_decl, Klassen: MappingRuleCS, MappingDeclarationCS (with setBlackbox(true));</b>\r\n}\r\n<b>AST: ModuleInterfaceCS[methods = ..., moduleHeader = ..., metamodels = ModelTypes aus Parametern]</b>\r\n<b>CST: ModuleInterface</b>\r\n\r\n \r\nmodule Sink mexport ISink\r\n<b>AST: ModuleHeaderCS, ExportCS[pathNameCS = \"ISink\"] &lt;581&gt;</b>\r\n{\r\n\tmimport ISEFFRegistry;  \r\n\tmimport ISEFFUtil;\r\n\tmimport ICommons;\r\n\tmimport IOperationSignatureRegistry;\r\n\t\t\r\n\tmapping Sink_createSinkOperationProvidedRole(sinkComponent : pcm::repository::RepositoryComponent,\r\n\t                                             operationInterface : pcm::repository::OperationInterface) : pcm::repository::OperationProvidedRole {\r\n\t\t\tentityName := operationInterface.entityName+<em>'OperationProvidedRole'</em>+Commons_getUniqueElementNameSuffix();\r\n\t\t\tprovidingEntity_ProvidedRole := sinkComponent;\r\n\t\t\tprovidedInterface__OperationProvidedRole := operationInterface;\r\n\t}\r\n\t\r\n\t<b>&lt;851&gt; - implementations of mapping/helper methods: mapping_def / entry_def / helper_simple_def / helper_compund_def, Klassen: MappingMethodCS, MappingQueryCS, ModulePropertyCS</b>\r\n}\r\n</pre>\r\n\r\n### Changes to the grammar QVTOParser.gi\r\n<pre>%Globals\r\n\t/.\t\r\n\t<em>[...]</em>\r\n\timport org.eclipse.m2m.internal.qvt.oml.cst.ModuleHeaderCS;\r\n\timport org.eclipse.m2m.internal.qvt.oml.cst.MappingMethodCS;\r\n\timport org.eclipse.m2m.internal.qvt.oml.cst.InterfaceInOutParamCS;\r\n\timport org.eclipse.m2m.internal.qvt.oml.cst.InterfaceParamsCS;\r\n\timport org.eclipse.m2m.internal.qvt.oml.cst.InterfaceRestrictionParamCS;\r\n\t./\r\n%End\r\n\r\n%KeyWords\r\n\t<em>[...]</em>\r\n\tmodule\r\n\tinterface\r\n\tmimport\r\n\tmexport\r\n\tscope\r\n\tcompilation_environment\r\n%End\r\n\r\n\r\n%Rules\r\n\t<em>[...]</em>\r\n\tunit_element -> compilation_env\r\n\t\r\n\tcompilation_env ::= compilation_environment uri ';'\r\n\t\r\n\tunit_element -> module_def\r\n\tunit_element -> interface_def\r\n\t\r\n\tmodule_def ::= module_h mexport exportList '{' importList declarationList '}' semicolonOpt\r\n\tmodule_h ::= module qualifiedNameCS\r\n\r\n\texportList ::= qualifiedNameCS\r\n\texportList ::= exportList ',' qualifiedNameCS\r\n\t\r\n\tfullImport ::= mimport qualifiedNameCS ';'\r\n\timportList ::= %empty\r\n\timportList ::= importList fullImport\r\n\t\r\n\tinterface_def ::= interface_h '{' interfaceList '}' semicolonOpt\r\n\tinterface_h ::= interface qualifiedNameCS interfaceParams\r\n\r\n\tinterfaceParams ::= '(' interfaceInOutParamList ')'\r\n\tinterfaceParams ::= '(' interfaceInOutParamList ';' interfaceRestrictionList ')'\r\n\t\r\n\tinterfaceInOutParamList ::= interfaceInOutParamList ',' interfaceInOutParam\r\n\tinterfaceInOutParamList ::= interfaceInOutParam\r\n\r\n\tinterfaceRestrictionList ::= interfaceRestrictionList ',' interfaceRestrictionParam\r\n\tinterfaceRestrictionList ::= interfaceRestrictionParam\r\n\tinterfaceRestrictionParam ::= param_direction typespec '[' typespecList ']'\r\n\tinterfaceRestrictionParam ::= param_direction typespec '[' typespecList ']' '{' typespecList '}'\r\n\t\t\r\n\tparamWithDirection ::= param_direction IDENTIFIER ':' typespec\r\n\t\t\r\n\tinterfaceInOutParam ::= paramWithDirection\r\n\t\t\r\n\ttypespecList ::= %empty\r\n\ttypespecList ::= typespec\r\n\ttypespecList ::= typespecList ',' typespec\r\n\t\r\n\t<em>-- returns a MappingRuleCS</em>\r\n\tinterfaceElement -> mapping_decl\r\n\t<em>-- returns a MappingQueryCS</em>\r\n\tinterfaceElement -> helper_decl\r\n\t\r\n\tinterfaceList ::= interfaceList interfaceElement\r\n\tinterfaceList ::= interfaceElement\r\n\r\n\t<em>-- return a MappingMethodCS</em>\r\n\tdeclarationItem -> mapping_def\r\n\tdeclarationItem -> entry_def\r\n\t<em>-- return a MappingQueryCS->MappingMethodCS</em>\r\n\tdeclarationItem -> helper_simple_def\r\n\tdeclarationItem -> helper_compound_def\r\n\t\r\n\tdeclarationItem -> _property\r\n\r\n\tdeclarationList ::= declarationList declarationItem\r\n\tdeclarationList ::= declarationItem\r\n\t\r\n\t<em>-- changed code ---</em>\r\n\tscoped_identifier ::= scoped_identifier2\r\n\tscoped_identifier2 ::= IDENTIFIER '@' IDENTIFIER\r\n%End</pre>\r\n\r\n### The new metamodels\r\n#### AST\r\n<a href=\"http://dwerle.github.io/qvtom/images/QVTOperationalAST.png\"><img src=\"http://dwerle.github.io/qvtom/images/QVTOperationalAST_thumb.png\" alt=\"AST metamodel\" /></a>\r\n#### CST\r\n<a href=\"http://dwerle.github.io/qvtom/images/QVTOperationalCST.png\"><img src=\"http://dwerle.github.io/qvtom/images/QVTOperationalCST_thumb.png\" alt=\"CST metamodel\" /></a>\r\n\r\n### How to include new elements into the CST/AST\r\n0. Once: adapt \"/org.eclipse.m2m.qvt.oml.cst.parser/cst/run-lpg.cmd\" (LPG_HOME, LPG_EXE, PERL_EXE)\r\n  * Warning: spaces in path names can lead to problems\r\n1. Augment CST and AST metamodels, generate Java code.\r\n  * /org.eclipse.m2m.qvt.oml.cst.parser/model/QVTOperationalCST.ecore\r\n  * /org.eclipse.m2m.qvt.oml/model/QVTOperational.ecore\r\n2. Add new keywords to \"/org.eclipse.m2m.qvt.oml.cst.parser/cst/QVTOKWLexer.gi\" (export **and** rule)\r\n3. In \"/org.eclipse.m2m.qvt.oml.cst.parser/cst/QVTOParser.gi\"\r\n  * Import keywords (%KeyWords)\r\n  *\tAdd rules with reference to factory method in org.eclipse.m2m.internal.qvt.oml.cst.parser.AbstractQVTParser\r\n  * If possible, call `setOffsets` appropriatelyIn der Regel wenn möglich auch setOffsets entsprechend aufrufen.\r\n4. Call \"/org.eclipse.m2m.qvt.oml.cst.parser/cst/run-lpg.cmd\"\r\n5. If top level elements have been created (such as ModuleImplementation/ModuleInterface/CompilationEnvironment), add them to `org.eclipse.m2m.internal.qvt.oml.cst.parser.AbstractQVTParser.setupTopLevel(EList<CSTNode>)`\r\n\r\n\r\n### Changes to the CST (/org.eclipse.m2m.qvt.oml.cst.parser/model/QVTOperationalCST.ecore)\r\n* Changes to UnitCS\r\n  * Reference to `ModuleImplementations` and `ModuleInterfaces`\r\n* New: ModuleHeaderCS\r\n* New: ModuleInterfaceCS\r\n* New: InterfaceInOutParamCS\r\n* New: InterfaceRestrictionParamCS\r\n* New: InterfaceParamsCS – eventuell entferenen\r\n* New: ModuleImplementationS\r\n* New: ExportCS\r\n* New: CompilationEnvironmentCS\r\n  * Only references the name of a part of the \"Compilation Environment\", i.e. all files that have to be compiled together.\r\n\r\n### Changes to the AST (/org.eclipse.m2m.qvt.oml/model/QVTOperational.ecore)\r\n* New: ModuleInterface\r\n  * Interface of a module, defines in/out/inout metamodels, visibility of the metamodel and method signatures\r\n* New: InterfaceInOutParameter\r\n  * Same as the in/out/inout parameters of a QVTo transformation but is defined for each ModuleInterface.\r\n* New: InterfaceRestrictionParameter\r\n  * Parameter to restrict the visibility of the metamodel\r\n* New: ModuleImplementation\r\n  * Implementation of a module, exports at least one interface and has to implement at least the methods of the exported interface(s).\r\n\r\n### org.eclipse.m2m.internal.qvt.oml.compiler.QVTOCompiler\r\nThe entry point for the changes from QVTo to QVTom start in `org.eclipse.m2m.internal.qvt.oml.compiler.QVTOCompiler` in the method `doCompileQVTom`, which replaces `doCompileQVTo`. For the compilation of QVTom in multiple files the following stages are performed:\r\n\r\n1. Parse all files that are declared as part of the \"Compilation Environment\" in the file.\r\n2. Create `ModuleInterfaces` (`createModuleInterfaceStubs`) for every CST, i.e. start the visitor (`QVTOperationalVisitorCS`) for every CST (every file).\r\n3. Resolve all cross references between modules (`crossReferenceModules`). Copy all references to every module interface (the elements that are used to resolve calls to methods of foreign modules) between each two environments of `CSTParseResult`s (of type `QVTOperationalFileEnv`).\r\n4. Compile (CST -> AST) every imported file.\r\n5. Perform a transformation of the resulting QVTom-ASTs to a QVTO-AST which can be interpreted/compiled with the default interpreter/compiler.\r\n\r\n### org.eclipse.m2m.internal.qvt.oml.qvtom2qvto.QVTom2QVToCSTransformation\r\nThe linking of method calls etc. is already performed during the compilation. For the transformation from QVTom to QVTo the following steps have to be performed:\r\n\r\n1. Copy all methods from the module interfaces and module implementations to a new `OperationalTransformation`.\r\n2. Copy in/out/inout parameters to the new transformation.\r\n3. Create properties from the modules in the new transformation.\r\n\r\n### Changes to org.eclipse.m2m.internal.qvt.oml.ast.parser.QvtOperationalVisitorCS\r\nWas modified to be able to handle the new syntax elements.\r\n\r\n#### lookupModelParameter(SimpleNameCS, DirectionKind, QvtOperationalEnv)\r\nAllows the referencing of `ModelParameter`s that are declared in the interface, i.e. the parsed parameters from the `ModuleInterface` which are `InterfaceInOutParameter`s are made referenceable.\r\n\r\n#### QvtOperationalVisitorCS.genOperationCallExp(...)\r\nIf no local mapping can be found, check if a fitting method can be found in an imported module. For this purpose traverse upwards in the environment hierarchy until a fitting environment (of type `QvtOperationalFileEnv`) has been found and check if one of the imported interfaces implements a fitting method.\r\n\r\n#### visitMappingDeclarationCS(...)\r\nCheck the visibility of the context types of the mappings.\r\n\r\n#### visitResolveInExpCS(...)\r\nAllow the resolution of methods in the same `ModuleImplementation` or in imported interfaces.\r\n\r\n### New methods for modularity in QvtOperationalVisitorCS\r\n\r\n#### registerModelTypes(...)\r\nHelper method that is used by `visitModuleInterface`and `visitModuleImplementation`. Parses the used `ModelType`s (`visitModelTypeCS`) and references them in the created Module (`getUsedModelType().add(...)`), adds them as types to the module (`.getEClassifiers().add(...)`) and register them in the environment.\r\n\r\n#### visitModuleInterface(...)\r\nVisitor method for `ModuleInterface`s, comparable to the visitor methods for methods.\r\n\r\n1. Register `ModelType`s in the environment.\r\n2. Register the `ModelInterface` in the environment.\r\n3. Visit and reference `InOutParameters`and `RestrictionParameter`s.\r\n4. Visit all `MappingDeclaration`s for methods and reference results.\r\n\r\n#### visitInOutParamsCS(...)\r\nVisitor methods for `InOutParameter`s.\r\n\r\n#### visitRestrictionParamsCS(...)\r\nVisitor method for `RestrictionParam`s. All types are resolved and checked for containment of the package that is to be restricted.\r\n\r\n#### visitModuleImplementation(...)\r\nVisitor method for `ModelImplementation`s.\r\n\r\n1. Register `ModelType`s in the environment\r\n2. Create `ModelImplementation` and register it in the enviroinment.\r\n3. Create a new module environment (\"moduleEnv\") which encapsulates the contained methods and represents the module.\r\n   * This is necessary to allow the free distribution of the interfaces and implementations to multiple files.\r\n   * Imported interfaces and variables for used meta models are saved in the interface.\r\n4. Create properties (`createModuleImplementationProperties`)\r\n5. Resolve exports (`resolveExports`), i.e. resolve and reference each interface that is declared as export.\r\n6. Resolve imports, i.e. resolve and reference each interface that is declared as import.\r\n7. Pass through all contained methods\r\n   1. Register contained method in `moduleEnv` (cf. `visitMappingModule`), i.e. create empty methods that can be referenced.\r\n   2. Visit methods (references to empty methods are resolvable).\r\n   3. Check if visibility declarations are violated.\r\n      * `validateMethodMetaModelVisibility(ModuleImplementation, QvtOperationalEnv)`\r\n      * `OCLRestrictedTypeVisitor(ModuleImplementation, QvtOperationalEnv)`\r\n   4. Set entry operation\r\n   5. Export the methods to the interface, cf. `exportMethodsToInterface(...)``\r\n8. Pass the errors from the module environment to the parent environment to make them visible in the IDE.\r\n\r\n#### exportMethodsToInterface(...)\r\nIn our implementation the method bodies are copied into the interface after the methods are visited (i.e. they are not referenced). We chose this seemingly complicated implementation to allow our modifications to be as non-invasive as possible and to allow the visitor methods for the mappings to perform unchanged.\r\n\r\nThis method also checks the exported interfaces for complete implementation in the `ModuleImplementation` and reports errors if necessary.\r\n\r\n## Meta model visibility validation\r\nThe validation of the meta model visibility is realized in two new classes which are explained below. The entry point into the validation can be found in two places:\r\n* `org.eclipse.m2m.internal.qvt.oml.ast.parser.QvtOperationalVisitorCS.validateMethodMetaModelVisibility(ModuleImplementation, QvtOperationalEnv)`\r\n* `QvtOperationalVisitorCS.visitMappingDeclaration(…)`\r\n\r\n### OCLRestrictedTypeVisitor\r\nIs created with a `TypeRestrictionSet`or a `ModuleImplementation`. When passing a `ModuleImplementation` the appropriate `.buildFromInterface` method of the `TypeRestrictionSet` is called.\r\n\r\nThe visitor itself extends `OCLAbstractVisitor`. Every possible violation of the meta model visibility can be checked and annotated with an appropriate error or warning if necessary.\r\n\r\n### TypeRestrictionSet\r\nRepresents a set of types and packages that are accessible for a particular direction (`DirectionKind`) and possibly for a particular extent.\r\n\r\n## QVTo(m)-Environments\r\nEnvironments are created but not mandatorily persited. They can be used solely for the `QVTOperationalVisitorCS` and discarded afterwards.\r\n* `org.eclipse.m2m.internal.qvt.oml.ast.parser.QvtOperationalVisitorCS.visitObjectExpCS(ObjectExpCS, QvtOperationalEnv, boolean)` -- creates a temporary environment.\r\n* `org.eclipse.m2m.internal.qvt.oml.ast.parser.QvtOperationalVisitorCS.visitModuleImplementation(ModuleImplementationCS, QvtOperationalFileEnv)` -- create a temporary environent for the module so the parsed methods from different modules in the same file context do not interfere.\r\n\r\n### org.eclipse.m2m.internal.qvt.oml.ast.env.QvtOperationalEnv\r\n* `org.eclipse.m2m.internal.qvt.oml.ast.env.QvtOperationalEnv.registerMappingOperation(MappingOperation, boolean)`\r\n  * Copy of the equally named method without the boolean parameter. Makes it possible to prevent the registration in the parent environment.\r\n* Additional attributes for the `ModuleImplementation`s and `ModuleInterface`s with respective getters and setters.\r\n* Additional attribute of type `EntryOperation` which represents the entry point for the execution of the transformation.\r\n\r\n### org.eclipse.m2m.internal.qvt.oml.ast.env.QvtOperationalModuleEnv, org.eclipse.m2m.internal.qvt.oml.ast.env.QvtOperationalFileEnv\r\n* Concrete subtypes which allow the getting/setting of `ModuleImplementation`s and `ModuleInterface`s.\r\n\r\n## Import mechanism of QVTo and QVTom\r\nIt is already possible to connect multiple transformations by an import mechanism in QVTo. Details for this mechanism can be found in the QVT standard.\r\n\r\n## Workflow of the QVTo(m) parser and interpreter\r\n<img src=\"http://dwerle.github.io/qvtom/images/Workflow.png\" />\r\n\r\nImage after <em>Erweitern eines Code-Editors unter Eclipse um neue Sprachkonzepte</em> by Ivayla Partalina.\r\n\r\n### Plugins/Packages/Classes\r\n* org.eclipse.m2m.qvt.oml\r\n  * org.eclipse.m2m.internal.qvt.oml.ast.env\r\n    * defines the used environments\r\n    * type checking\r\n  * org.eclipse.m2m.internal.qvt.oml.ast.parser\r\n    * QvtOperationalVisitorCS: conversion from CST to AST\r\n    * OCLRestrictedTypeVisitor / TypeRestrictionSet / ExtentClassifier / ExtentPackage – meta model visibility validation\r\n    * OCLAbstractVisitor – abstract implementation of QVTOperationalVisitor<Boolean>, base for OCLRestrictedTypeVisitor\r\n    * QvtOperationalParser – set up the root element for the parse result (UnitCS)\r\n* org.eclipse.m2m.internal.qvt.oml.compiler\r\n  * QVTOCompiler – entry point into the compilation\r\n* org.eclipse.m2m.internal.qvt.oml.evaluator\r\n  * QvtOperationalEvaluationVisitor / QvtOperationalEvaluationVisitorImpl – interpreter interface and impkementation. adapted to support module implementations and interfaces\r\n* org.eclipse.m2m.internal.qvt.oml.qvtom2qvto\r\n  * QVTom2QVToCSTransformation – transformation from QVTom to QVTo (to reuse the QVTo interpreter)\r\n* org.eclipse.m2m.internal.qvt.oml.cst.parser\r\n  * AbstractQVTParser – Methods that are called from the parser (LPG).\r\n* org.eclipse.m2m.qvt.oml.editor.ui\r\n* org.eclipse.m2m.qvt.oml.runtime\r\n* org.eclipse.m2m.qvt.oml.runtime.ui\r\n\r\n\r\n## Example for parsing and environments\r\n### Source code\r\n```\r\nmodeltype ECORE uses 'http://www.eclipse.org/emf/2002/Ecore';\r\nmodeltype UML uses 'http://www.eclipse.org/uml2/4.0.0/UML';\r\n\r\ninterface I_A(\r\n\tin ecore:ECORE,\r\n\tout uml:UML\r\n) {\r\n\tmapping EClass::EClass2Class() : Class;\r\n}\r\n\r\nmodule A mexport I_A {\r\n\tmapping EClass::EClass2Class() : Class {\r\n\t\tname := self.name;\r\n\t}\r\n}\r\n```\r\n\r\n### Partial dump of the resulting CompiledUnit\r\n```\r\nresult = CompiledUnit [\r\n  moduleEnvs = [\r\n    QvtOperationalFileEnv [\r\n      parent = null,\r\n      myFile = \".../minimal.qvto\",\r\n      myModuleImplementations = [\r\n        ModuleImplementation[\r\n          name = \"A\",\r\n          eOperations = [MappingOperation[name=\"EClass2Class\"]]\r\n        ]\r\n      ],\r\n      myModuleInterfaces = [\r\n        ModuleInterface[\r\n          name = \"I_A\",\r\n          operations = [MappingOperation[name=\"EClass2Class\"]]\r\n        ]\r\n      ]\r\n    ]\r\n  ]\r\n]\r\n```\r\n\r\n## See Also\r\n* [Modular Model Transformations](https://sdqweb.ipd.kit.edu/wiki/Modular_Model_Transformations), the overall approach behind this project, as well as information for developers.\r\n* [Xtend2m](http://qvt.github.io/xtend2m/), a modular extension of Xtend hosted at Github.\r\n\r\n## References\r\n1. A. Rentschler, D. Werle, Q. Noorshams, L. Happe, R. Reussner. [*Designing Information Hiding Modularity for Model Transformation Languages*](http://dl.acm.org/citation.cfm?doid=2577080.2577094). Proceedings of the 13th International Conference on Modularity (AOSD '14), Lugano, Switzerland, April 2014. ACM, New York, NY, USA. April 2014.\r\n2. [Eclipse Modeling - MMT - Project QVTo](http://www.eclipse.org/mmt/?project=qvto)\r\n\r\n## Contributors\r\n* [Dominik Werle](mailto:dominik.werle_AtSignGoesHere_student.kit.edu) from Karlsruhe Institute of Technology\r\n* [Andreas Rentschler] (http://sdq.ipd.kit.edu/people/andreas_rentschler/) from Karlsruhe Institute of Technology\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}